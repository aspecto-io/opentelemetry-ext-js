
# Express Routing

Internally, express has 4 types of routing components. we will call them by the names: `Layer`, `Router`, `Route` and `application`.

## Components 
### Layer (user's middleware)
This is a thin wrapper around user's supplied middleware function. For example:
```js
const middleware = (req, res, next) => { 
    // some code
};
app.use(middleware);
```

The middleware is just a function with specific arguments and semantics. When you attach it to another layer (router or route) by calling `use`/`all`/`get` etc , express wraps the supplied function `fn` in a thin `Layer` object, and save it as `handler` attribute on the `Layer`

A layer also has a `path`, which is used by express to compare the prefix of a givin url target to the layer and decide if it should run or not.

Since internally express is differentiating between request (normal) handlers, and error handlers, `Layer` define `handle_request` function and `handle_error` function, which are the functions to be called by the executer of the layer (`Router` or `Route`), these functions also take care of exception catching and validating the function signature.

### Router
A `Router` is middleware with some predefined logic, and it can be used everywhere a middleware is expected.
`Router` is a collection of other layers (middlewares, other `Router`s or `Route`s). 

Each `Router` has a `stack` property where it stores a list of the layers it contains. New layers can be attached to the `Router` by calling the `use` function, or one of http methods (`get`, `post`, etc) via `Route`.

Whenever user is creating a new `Router` with `const router = express.Router();` he is just creating a function of the form `(req, res, next) => {}`. When this function is served to express, it is wrapped internally by a `Layer`, and is used just like any other user's middleware. The `handler` function for router is predefined by express - when executed, it loops on the layers in the internal `stack` in order, check which layers should run, and execute them while connecting the `next` call from each `layer` to call the next layer.

Just like any other layer, when the router is done, it calls the `next()` function to return control to the layer which invoked it.

### Route
`Route` is matching HTTP verbs (`get`, `post`, etc), in a similar way to how `Router` is responsible for matching url path.

`Route` **is not** a `middleware`, and it is constructed and used differently from user's middleware or router.
- Unlike `Layer`, `Route` does not contain handler property or function to match the `path` and decide if it should run or not. The invocation function for a route is called `dispatch`. `Route` cannot be used where other `Layer`s are expected.
- Like `Router`, it contains a `stack` property where it holds other layers which it runs according to some matching logic. Similar to `Router`, when invoked, it too is looping on the layers of the stack, check if they should run, and invoke it after connecting the `next` function of one layer, to calling the handler of the following matched layer in the stack.

#### Using a Route
Unlike `Router` or user middleware which can be generated by the user and then register in express, `Route`s are created by calling `router.route(path)`, which creates the `Route` under some url path, and register it under a `Router` at the same time.
This call then returns a route object which can be used to register verbs (without path! route only handles verbs) in the following way:
```js
import * as express from 'express';
const router = express.Router();
const route = router.route('some-path');
route.post((req, res, next) => { /* middleware code */ })
```

Notice again that `Route` does not handle path! It can be registered on a router with a path that, if match, invoke the `layers` on the route based only on the request verb and the desired verb for each middleware.

There is a shortcut for this syntax which creates the route and register verbs at the same time:
```js
import * as express from 'express';
const router = express.Router();
router.post('some-path', (req, res, next) => { /* middleware code */ });
```
This syntax is creating a new `route`, register it on the givin router with the supplied `path`, and register the middleware array on the route under the givin verb.

#### Route Layer
Although `Route` is not a `Layer`, when `route()` function is called on a `Router`, it create a new `Route` and wrap it in a layer, which is treated mostly (but not always) as normal `Layer` in router's stack. The new `Layer` has a special property called `route` which can be used to differentiate a "route layer" from other layers. The `dispatch` function of the `Route`, is the `handler` function of the layer.

### Application
Application, in regards to routing, is just another `Router`. Everything you can do on a router, you can also do with `app`:
```js
import * as express from 'express';
const app = express.Router();
app.use('some-path', (req, res, next) => { /* middleware code */ });
```

## Relationships Between the Components
- A `Layer` on it's own is useless. It only has meaning when resides inside `Router` or `Route` which can invoke it.
- A `Route` on it's own is useless. It can be created and run only by `Router`.
- `Layer` is just a wrapper for running middleware function. It is the atoms out of which express routing is build.
- `Router` can contain `Layer`s (user custom middleware), `Route`s, and off course - other `Router`s.
- `Route` can contain `Layer`s (user custom middleware), but it cannot contain other `Route`s directly (and it really doesn't make sense to do it).
- `Application` is where you start your routing from (just like any `Router`).

## Path Handling while Routing
Express in quite advanced when talking about modularity and routing. The architecture is built in such a way that routing components can be defined and reused in various places without considering the whole url path, but just the part which is of interest.

For example, you can define a `Router` like this:
```js
const router = express.Router()
    .use('/some-entity', (req, res, next) => { 
        // do something with request
    })
```

and then mount this router under other path:
```js
const app = express();
app.use('/api/v1', router);
```
The router does not know or care that it is running under `/api/v1` when invoked, express will take care of stripping the matched prefix `/api/v1` and invoke the router as if the url is just `/some-entity/...`.

User can reuse this router in a different path, different application, or just place it in another file which focuses only on the scope of `some-entity`, and decouple it from it's users and downstream routes.

### Stripping Matched Parts in Path
As we said before, express is taking care of matching the request path as it traversing the routing components. So if you add a router under some path, this router will behave as a "mini app", being aware only to the parts which has not been matched yet.

Each middleware can examine the "remaining" part of the url path which has not been consumed yet, by calling `req.path`:
```js
app.use('/foo', (req, res, next) => {
	console.log(`path without route: ${req.path}`);
	res.send('hello world');
});
```

Calling the above middleware with url `/foo` will print `"path without route: /"`, and calling it with `/foo/bar` will print `"path without route: /bar"`. We can see that the middleware consumed the `/foo` part, and was left with the remaining path `/bar`

Unfortunately, there is an annoying exception with `Route`s - they must consume the remaining path all the way to the end:
```js
import express from 'express';
const app = express();

// the 'get' signature create a `Route` with one middleware in it.
app.get('/foo', (req, res, next) => {
	console.log(`path in route: ${req.path}`);
	next();
});

// the 'use' signature creates just a regular `Layer`
app.use('/foo', (req, res, next) => {
	console.log(`path without route: ${req.path}`);
	res.send('hello world');
});

app.listen(1234, () => console.log('started server on port 1234'));
```
When called with url `http://localhost:1234/foo`, console output will be:
```
path in route: /foo
path without route: /
```
As you can see, `Route` is not stripping the matched prefix `/foo`!!!

Another exception is that `Route` path must match to the end of the path. calling the previous example with url: `http://localhost:1234/foo/bar` will produce:
```
path without route: /bar
```
Since `/foo/bar` does not match `/foo` until the end (only the prefix).

This instrumentation library is taking care of the various possibilities, to guarantee that correct full url is generated at any scenario.


## Calculating Route in Instrumentation

### How "Route" is Defined
It is not imidiately obvious what is the definition of "Route" in express application. There could be multiple routers which can handle the request based on multiple paths.

Each http request is handled in express as a linear series of middlewares where each one calls the next (if it matches the path and verb).
At one point, one middleware is not calling the `next` function, which will terminate the middleware chain.

So we have the termination of the middleware chain on one hand. On the other hand we have the termination of the request (by calling `res.end()`, or by calling one of the other function that is calling `res.end()`).

Those two terminations are usually being performed in the same middleware (the middleware that calls `res.end()` is usually the same one that stops the chain by not invoking `next()`), and are synchronized (the call to `res.end()` happens in the same async context of the last middleware not calling `next()`). These are just the common case, but it is completely valid and supported to configured an application which does not hold this property.

This instrumentation defined the HTTP_ROUTE as the active route at which `res.end` is called (in regards to whether the middleware execution stack got terminated as well or not).

The active route is also something that needs explanation. Although the middleware chain is linear by nature (series of middlewares calling one another), there an hirarchey in the `Router`s and `Route`, which is responsible for how the path is handled. For each middleware, it's active route is the concatenation of all the paths in the layer above it in the hirarchey. This also correlates with the actual way that the path is being trimmed and restored during the traversal in the various routing components.

